%TCIDATA{LaTeXparent=0,0,relatorio.tex}
                      
\chapter{Desenvolvimento}\label{CapDesenvolvimento}

% Resumo opcional. Comentar se não usar.
%\resumodocapitulo{Resumo opcional.}

\section{Introdu\c{c}\~{a}o}

Neste capítulo será apresentado o histórico dos estilos de codificação, que tiverem origem com a notação húngara, nos anos 70. Em seguida serão apresentados os estilos mais prominentes, como os estilos Gnu/C, Java, C++ e Python.

\section{Histórico dos padrões de codificação}

\subsection{Notação Húngara}

A notação húngara, hoje chamada Apps húngaro, foi inventada por Charles Simonyi, um programador que trabalhou na Xerox PARC entre1972 e 1981, e que mais tarde se tornou arquiteto-chefe da Microsoft \cite{notacao2015}.
 
A notação é uma referência para os estilos de codificação existentes, pois foi a partir dela que teve início o processo de definir um determinado estilo de codificação a ser seguido dentro de um projeto. A notação húngara utiliza prefixos para indicar o tipo de informação que está sendo  armazenada, fazendo com que desenvolvedores decorem nomes de identificadores baseados na informação semântica que eles armazenam \cite{notacao2015}.  Esses prefixos são letras minúsculas associadas ao conteúdo ou tipo da variável ou identificador. A Tabela \ref{tab2} lista os indicadores mais utilizados na notação húngara.

\begin{table}[ht]
        \caption{Indicadores da notação húngara}
        \label{tab2}
        \begin{center}

        \begin{tabularx}{0.7\textwidth}{lX}
        \toprule
        	\textbf{Nome} & \textbf{Descrição} \\
        \midrule
	       	s & String \\ 
        \rowcolor[gray]{0.8}
		sz & Aponta o primeiro caracter de uma string terminada em zero \\ 
		st & Ponteiro da string, o primeiro byte é contador dos caracteres \\ 
        \rowcolor[gray]{0.8}
		h & Handle \\ 
		msg & Mensagem \\ 
        \rowcolor[gray]{0.8}
		fn & Função (ponteiro) \\ 
		c & char (8 bits) \\ 
        \rowcolor[gray]{0.8}
		by & unsigned char (byte or uchar ¿ 8 bits) \\ 
		n & Inteiro \\ 
        \rowcolor[gray]{0.8}
		b & Booleana (verdadeiro ou falso) \\ 
		f & Flag (boolean, logical) \\ 
        \rowcolor[gray]{0.8}
		u & Inteiro não sinalizado \\ 
		w & Word (Variável com o tamanho de um registrador da máquina) \\ 
        \rowcolor[gray]{0.8}
		ch & Char, com texto ASCII \\ 
		l & Inteiro longo (32 bits) \\ 
        \rowcolor[gray]{0.8}
		dw & Inteiro longo não sinalizado (dword 32 bits) \\	
		pX & Ponteiro para X \\ \bottomrule
        \end{tabularx}
        \end{center}
\end{table}

Um bom desenvolvedor geralmente deve considerar os identificadores como valores mnemônicos que facilitem a lembrança do significado do nome da variável criada pelo programador; que sejam sugestivos, facilitando a leitura dos demais desenvolvedor; e que sejam simples de identificar, de modo que o desenvolvedor não perca tempo pensando para que ou em qual contexto aquela variável será utilizada \cite{notacao2015}. 

A Tabela \ref{tabVarNtHun} exemplifica várias tipos de identificadores em notação húngara e seus respectivos significados e tipos.

\begin{table}[ht]
        \caption{Variáveis utilizando notação húngara}
        \label{tabVarNtHun}
        \begin{center}
        \begin{tabularx}{0.7\textwidth}{lX}
        \toprule
                \textbf{Nome} & \textbf{Descrição} \\
        \midrule
                bBusy & boolean \\
	\rowcolor[gray]{0.8}
		chInitial & char \\ 
		cApples & count of items \\ 
	\rowcolor[gray]{0.8}
		dwLightYears & double word \\ 
		fBusy & float \\ 
	\rowcolor[gray]{0.8}
		nSize & integer or count \\ 
		iSize & integer or index \\ 
	\rowcolor[gray]{0.8}
		fpPrice & floating-point \\ 
		dbPi & double \\ 
	\rowcolor[gray]{0.8}
		pFoo & pointer \\
		rgStudents  & array, or range \\ 
	\rowcolor[gray]{0.8}
		szLastName  & zero-terminated string \\
		u32Identifier  & unsigned 32-bit integer \\
	\rowcolor[gray]{0.8}
		stTime & clock time structure \\
		fnFunction  & function name \\
	\rowcolor[gray]{0.8}
		pszOwner  & pointer to zero-terminated string \\
		rgfpBalances  & array of floating-point values \\
	\rowcolor[gray]{0.8}
		aulColors & array of unsigned long \\
		hwndFoo  & handle to a window \\
	\rowcolor[gray]{0.8}
		lpszBar  & long pointer to a zero-terminated string \\
		g\_nWheels & member of a global namespace, integer \\
	\rowcolor[gray]{0.8}
		m\_nWheels & member of a structure/class, integer \\
		m\_wheels,\_wheels  & member of a structure/class \\
	\rowcolor[gray]{0.8}
		s\_wheels  & static member of a class \\
		c\_wheels & static member of a function \\ \bottomrule
        \end{tabularx}
        \end{center}
\end{table}

O sistema húngaro foi adotado como padrão de programação do Windows, e se espalhou amplamente por meio de livros como \cite{charles2002}, a bíblia para aprender programação do Windows . Rapidamente a notação húngara se tornou o estilo de codificação dominante utilizado em códigos escritos em linguagem C \cite{notacao2015}.

Mas, por algum motivo não divulgado ao público, com a primeira versão da plataforma .NET, a Microsoft começou a abandonar o uso da notação húngara. A equipe de projetos do Excel e Word ficaram aliviados em não ter que usar uma convenção de nomenclatura estranha, já que nos dias atuais a verificação de declaração dos tipos de variáveis é feita pelo compilador e há o recurso de autocompletar o código digitado que sugere um conjunto de opções ao programador, a depender do contexto \cite{notacao2015}.

\subsection{GNU C}

O estilo de codificação Gnu/C foi proposto e definido por Richard Stallman e outros voluntários do projeto GNU em meados de 1992, pois Stallman acreditava que a adoção de um padrão tornaria os programas e componentes GNU limpos, consistentes e de fácil manutenção.

Para que um novo desenvolvedor possa participar de algum projeto ou criar algo para a comunidade do software livre GNU, é exigido apenas que ele se atente ao  documento oficial de estilos\footnote{http://www.gnu.org/prep/standards/}.  É de suma importância que se utilize a versão atualizada, para que não seja escrito um código formatado sobre regras que possam ter sido revogadas ou substituídas.

Também é possível que o desenvolvedor faça uma contribuição para o documento que descreve o estilo de codificação GNU/C. Caso ele detecte alguma inconsistência ou uma possível evolução em um determinando conteúdo, basta enviar um email para bug-standards@gnu.org  com a descrições das contribuições \cite{stallman2015}.

O estilo GNU proposto para a linguagem C possui características próprias no que se refere à formatação, comentários, convenção de nomes, tabulações, espaços e indentações, dentre outros.

\subsection{Formatação}

O estilo de codificação Gnu/C utiliza 79 caracteres para o comprimento das linhas. Segundo Stallman, esta caraterística facilita a leitura do código nos mais diversos ambientes e editores.
O estilo também recomenda a utilização de colchetes "{}", para o bloco da função em linha posterior à da declaração da função e ao final do bloco. O Código \ref{formatGnuC}, exemplifica a formatação mencionada.

\lstinputlisting[language=C, caption=Formatação GNU C, label=formatGnuC]{cods/formatgnu.c}

\subsection{Comentário}

Stallman diz que todo programa deve começar com um comentário no topo do código-fonte contendo a função 'principal' do programa. Este comentário deve informar o nome do arquivo e apresentar uma ou duas linhas a respeito do objetivo geral do programa. As estruturas e as funções devem trazer comentários com a descrição sobre sua funcionalidade, quais os tipos de argumentos pode receber e o seu tipo de retorno, quando houver.

É  recomendado que os comentários sejam escritos em inglês. A justificativa é que o inglês é o idioma comum para quase todos os desenvolvedores, tornando possível a um grande número de pessoas entenderem o que foi definido naquela função.

O Código \ref{comentGnuC} exemplifica um programa com comentários no estilo GNU/C.

\lstinputlisting[language=C, caption=Comentários GNU C, label=comentGnuC]{cods/comentgnu.c}

\subsection{Convenção de nomes}

O nomes de variáveis e funções globais devem ser concisos, trazendo consigo informações úteis sobre o significado da variável ou função. Assim como o comentário, os identificadores devem ser escritos em  inglês. Variáveis locais podem conter nomes mais curto, porque elas são utilizadas apenas dentro de um contexto específico. É recomendado a utilização de sublinhados para separar palavras e nomes, de modo que os comandos possam ser legíveis. O estilo GNU/C sugere o uso apenas de letras minúsculas para identificadores de variáveis e funções, reservando maiúsculas para macros, constantes, enumerações e para prefixos que seguem uma convenção uniforme.

O Código \ref{varGnuC}, exemplifica uma variável cujo identificador segue o padrão GNU/C.

\lstinputlisting[language=C, caption=Variáveis Gnu C, label=varGnuC]{cods/vargnu.c}

\subsection{Indentação}

Segundo \cite{kernelorg2002}, a idéia por trás da indentação é definir claramente onde um bloco de controle começa e onde ele termina. A indentação, em geral, utiliza 8 caracteres, mas existem editores que utilizam apenas 4, ou até mesmo 2 caracteres. Porém, de acordo com \cite{kernelorg2002}, a definição do tamanho de uma indentação é um problema semelhante ao da definição de uma aproximação para o valor da constante $\pi$.

Apesar de algumas pessoas argumentarem que a utilização de 8 caracteres faz com que o código fonte fique muito deslocado à direita, o que como consequência faz com que seja difícil a leitura em uma tela de 80 caracteres, é desaconselhável a utilização de mais de 3 níveis de indentação em um mesmo bloco.

\subsection{Espaçamento}

De acordo com \cite{kernelorg2002}, um dos principais usos de espaços é a separação e destaque de palavras chaves que geralmente são acompanhadas de parênteses.

A Tabela \ref{palchaveGnuC} exemplifica algumas palavras chaves que utilizam espaço após sua declaração.

\lstinputlisting[language=C, caption=Palavras chaves espaços em brancos Gnu C, label=palchaveGnuC]{cods/palchavegnu.c}

Já a Tabela \ref{palchaveExcGnuC} exemplifica algumas palavras chaves que não  utilizam espaço após sua declaração.

\lstinputlisting[language=C, caption=Palavras chaves exceção espaços em brancos Gnu C, label=palchaveExcGnuC]{cods/palchaveexcgnu.c}

\section{Java}

Após ter sua solicitação de padronização negada pelos orgãos ISO/IEC e ECMA a empresa Sun Microsystems criou, em 1998, o Java Community Process (JCP), com o objetivo de ser um processo aberto e participativo para desenvolver e revisar as especificações de suas implementações de referência, das suítes de teste e do estilo de codificação da tecnologia Java.
 
A abertura do JCP permitiu que empresas concorrentes da Sun se tornassem participantes ativas da evolução da Tecnologia Java. Diferentemente da maioria dos processos de padronização existentes, é possível o envolvimento de pessoas físicas sem custos financeiros. Isso fez do JCP um ponto de atração para a discussão e evolução da tecnologia Java.
 
Em 13 de novembro de 2006 foi lançada a maior parte do Java como Software Livre sob os termos da GNU (GPL). Em 8 de maio de 2007 o processo de adoção da nova licença foi finalizado, tornando praticamente todo o código Java como software de código aberto, exceto uma pequena porção da qual a Sun não possui copyright \cite{javamagazine2013}.

[TODO perguntar sobre estas citações]

De acordo com \cite{javamagazinecj2013}, a linguagem Java, em sua criação, teve como base a linguagem C++, que por sua vez teve como base a linguagem C. Com isto a linguagem possui algumas características semelhantes às encontradas em C/C++, dentre elas os tipos de comentários e estruturas de seleção, repetição. Naturalmente há outras características que são únicas do Java, como comentários para documentação e convenção de nomenclatura, dentre outras.

\subsection{Formatação}
\label{sec:formatacao}
Segundo \cite{oracle2015}, a linguagem Java deve utilizar quatro espaços como unidade de recuo e evitar linhas com mais de 80 caracteres, uma vez que que recuos maiores ou linhas com mais de 80 caracteres não são bem tratadas por determinados terminais e ferramentas. Quando uma expressão não couber em uma única linha, ela deves ser interrompida de acordo com os seguintes  princípios:

\begin{enumerate}
\item após uma vírgula; 
\item antes de um operador;
\item a nova linha deve estar alinhada com o início de cada expressão, no mesmo nível da linha anterior.
\end{enumerate}

\subsection{Comentários}

De acordo com \cite{oracle2015}, todos os códigos-fontes devem começar com um comentário semelhante ao estilo GNU/C citado em \ref{sec:formatacao}. No estilo Java é necessário que o comentário contenha o nome da classe, informações sobre a versão, a data de criação e o aviso de direitos autorais.  Os comentários de implementação são delimitados por /*...*/ ou precedidos pelos caracteres //. Os comentários de documentação são conhecidos como "comentários doc" e são delimitadas pelos marcardos "/**" e "*/".

O Código \ref{comentjava} exemplifica o estilo de comentário Java para início de uma classe.

\lstinputlisting[language=Java, caption=Comentário Java ( \cite{oracle2015} com adaptações), label=comentjava]{cods/coment.java}

O Código \ref{comentumalinhajava} exemplifica comentários de linha única.

\lstinputlisting[language=Java, caption=Comentários de linha única em Java, label=comentumalinhajava]{cods/comentumalinha.java}

De acordo com \cite{javadocj2013}, a ferramenta JavaDoc fornece uma linguagem especifica para enriquecer os comentários da linguagem Java, pois baseia-se na inserção de textos explicativos em forma de um comentário especial, que antecedem o escopo de uma classe ou de um método, tendo a responsabilidade de apresentar o elemento que sucede o comentário.

Seu funcionamento  é baseado no uso de marcação de documentos  com doclets, gerando arquivos nos formatos HTML \textit{(HyperText Markup Language)}, SGML \textit{(Standard Generalized Markup Language)}, XML \textit{(EXtensible Markup Language)} ou RTF \textit{(Rich Text Format)}. Tais marcações são feitas através de comentários, contendo tags especiais que especificam quais informações serão inseridas, com objetivo de manter uma massa de conhecimento reutilizável em qualquer projeto que faça uso da classe em questão.

A Tabela 3.1, exibe algumas tags utilizadas pelo javaDoc e seu respectivo significado.

%\section{Seção}

%Meu texto da seção.

%\subsection{Sub-seção}

%Meu texto da sub-seção.

%\subsubsection{Sub-sub-seção}

%Meu texto da sub-sub-seção.

%Se necessário, use notas de rodapé \footnote{Essa é uma nota de rodapé.}

